I"3<h2 id="一起因">一、起因</h2>

<p>玩 Kubenretes 的基本都很清楚，Kubernetes 很多组件的镜像全部托管在 <code class="highlighter-rouge">gcr.io</code> 这个域名下(现在换成了 <code class="highlighter-rouge">k8s.gcr.io</code>)；由于众所周知的原因，这个网站在国内是不可达的；当时由于 Docker Hub 提供了 <code class="highlighter-rouge">Auto Build</code> 功能，机智的想到一个解决办法；就是利用 Docker Hub 的 <code class="highlighter-rouge">Auto Build</code>，创建只有一行的 Dockerfile，里面就一句 <code class="highlighter-rouge">FROM gcr.io/xxxx</code>，然后让 Docker Hub 帮你构建完成后拉取即可</p>

<p>这种套路的基本方案就是利用一个第三方公共仓库，这个仓库可以访问不可达的 <code class="highlighter-rouge">gcr.io</code>，然后生成镜像，我们再从这个仓库 pull 即可；为此我创建了一个 Github 仓库(<a href="https://github.com/mritd/docker-library">docker-library</a>)；时隔这么久以后，我猜想大家都已经有了这种自己的仓库…不过最近发现这个仓库仍然在有人 fork…</p>

<p>为了一劳永逸的解决这个问题，只能撸点代码解决这个问题了</p>

<h2 id="二仓库使用">二、仓库使用</h2>

<p>为了解决上述问题，我写了一个 <a href="https://github.com/mritd/gcrsync">gcrsync</a> 工具，并且借助 <a href="https://travis-ci.org/mritd/gcrsync">Travis CI</a> 让其每天自动运行，将所有用得到的 <code class="highlighter-rouge">gcr.io</code> 下的镜像同步到了 Docker Hub</p>

<p><strong>目前对于一个 <code class="highlighter-rouge">gcr.io</code> 下的镜像，可以直接替换为 <code class="highlighter-rouge">gcrxio</code> 用户名，然后从 Docker Hub 直接拉取</strong>，以下为一个示例:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 原始命令</span>
docker pull k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.0

<span class="c"># 使用同步仓库</span>
docker pull gcrxio/kubernetes-dashboard-amd64:v1.10.0
</code></pre></div></div>

<h2 id="三同步细节说明">三、同步细节说明</h2>

<p>为了保证同步镜像的安全性，同步工具已经开源在 <a href="https://github.com/mritd/gcrsync">gcrsync</a> 仓库，同步细节如下:</p>

<ul>
  <li>工具每天由 <a href="https://travis-ci.org/mritd/gcrsync">Travis CI</a> 自动进行一次 build，然后进行推送</li>
  <li>工具每次推送前首先 clone 元数据仓库 <a href="https://github.com/mritd/gcr">gcr</a></li>
  <li>工具每次推送首先获取 <code class="highlighter-rouge">gcr.io</code> 指定 <code class="highlighter-rouge">namespace</code> 下的所有镜像(<code class="highlighter-rouge">namesapce</code> 由 <a href="https://github.com/mritd/gcrsync/blob/master/.travis.yml">.travis.yml</a> <code class="highlighter-rouge">script</code> 段定义)</li>
  <li>获取 <code class="highlighter-rouge">gcr.io</code> 镜像后，再读取元数据仓库(<a href="https://github.com/mritd/gcr">gcr</a>) 中与 <code class="highlighter-rouge">namesapce</code> 同名文件(实际是个 json)</li>
  <li>接着对比双方差异，得出需要同步的镜像</li>
  <li>最后通过 API 调用本地的 docker 进行 <code class="highlighter-rouge">pull</code>、<code class="highlighter-rouge">tag</code>、<code class="highlighter-rouge">push</code> 操作，完成镜像推送</li>
  <li>所有镜像推送成功后，更新元数据仓库内 <code class="highlighter-rouge">namespace</code> 对应的 json 文件，最后在生成 <a href="https://github.com/mritd/gcr/blob/master/CHANGELOG.md">CHANGELOG</a>，执行 <code class="highlighter-rouge">git push</code> 到远程元数据仓库</li>
</ul>

<p>综上所述，如果想得知<strong>具体 <code class="highlighter-rouge">gcrxio</code> 用户下都有那些镜像，可直接访问 <a href="https://github.com/mritd/gcr">gcr</a> 元数据仓库，查看对应 <code class="highlighter-rouge">namesapce</code> 同名的 json 文件即可；每天增量同步的信息会追加到 <a href="https://github.com/mritd/gcr">gcr</a> 仓库的 <code class="highlighter-rouge">CHANGELOG.md</code> 文件中</strong></p>

<h2 id="四gcrsync">四、gcrsync</h2>

<p>为方便审查镜像安全性，以下为 <a href="https://github.com/mritd/gcrsync">gcrsync</a> 工具的代码简介，代码仓库文件如下:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  gcrsync git:<span class="o">(</span>master<span class="o">)</span> tree <span class="nt">-I</span> vendor
<span class="nb">.</span>
├── CHANGELOG.md
├── Gopkg.lock
├── Gopkg.toml
├── LICENSE
├── README.md
├── cmd
│   ├── compare.go
│   ├── monitor.go
│   ├── root.go
│   ├── sync.go
│   └── test.go
├── dist
│   ├── gcrsync_darwin_amd64
│   ├── gcrsync_linux_386
│   └── gcrsync_linux_amd64
├── main.go
└── pkg
    ├── gcrsync
    │   ├── docker.go
    │   ├── gcr.go
    │   ├── git.go
    │   ├── registry.go
    │   └── sync.go
    └── utils
        └── common.go
</code></pre></div></div>

<p>cmd 目录下为标准的 <code class="highlighter-rouge">cobra</code> 框架生成的子命令文件，其中每个命令包含了对应的 flag 设置，如 <code class="highlighter-rouge">namesapce</code>、<code class="highlighter-rouge">proxy</code> 等；<code class="highlighter-rouge">pkg/gcrsync</code> 目录下的文件为核心代码:</p>

<ul>
  <li><code class="highlighter-rouge">docker.go</code> 包含了对本地 docker daemon API 调用，包括 <code class="highlighter-rouge">pull</code>、<code class="highlighter-rouge">tag</code>、<code class="highlighter-rouge">push</code> 操作</li>
  <li><code class="highlighter-rouge">gcr.go</code> 包含了对 <code class="highlighter-rouge">gcr.io</code> 指定 <code class="highlighter-rouge">namespace</code> 下镜像列表获取操作</li>
  <li><code class="highlighter-rouge">registry.go</code> 包含了对 Docker Hub 下指定用户(默认 <code class="highlighter-rouge">gcrxio</code>)的镜像列表获取操作(其主要用于首次执行 <code class="highlighter-rouge">compare</code> 命令生成 json 文件)</li>
  <li><code class="highlighter-rouge">sync.go</code> 为主要的程序入口，其中包含了对其他文件内方法的调用，设置并发池等</li>
</ul>

<h2 id="五其他说明">五、其他说明</h2>

<p>该仓库不保证镜像实时同步，默认每天同步一次(由 <a href="https://travis-ci.org/mritd/gcrsync">Travis CI</a> 执行)，如有特殊需求，如增加 <code class="highlighter-rouge">namesapce</code> 等请开启 issue；最后，请不要再 fork <a href="https://github.com/mritd/docker-library">docker-library</a> 这个仓库了</p>

<p>转载请注明出处，本文采用 <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">CC4.0</a> 协议授权</p>
:ET